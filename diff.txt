
######################## DIFF for AuthorizedOriginReceiver.sol


######################## DIFF for OCR2DR.sol
<   enum Location { Inline, Remote }
---
>   enum Location {
>     Inline
>     // In future version we will add Remote location
>   }
26,27c29,30
<     string source; // Source code for Location.Inline or comma-separated URL(s) for Location.Remote
<     bytes secrets; // Encrypted secrets blob for Location.Inline or encrypted comma-separated URL(s) for Location.Remote
---
>     string source; // Source code for Location.Inline or url for Location.Remote
>     bytes secrets; // Encrypted secrets blob for Location.Inline or url for Location.Remote
77c80
<    * @param codeLocation The user provided source code location
---
>    * @param location The user provided source code location
79c82
<    * @param source The user provided source code or comma-separated URL(s)
---
>    * @param source The user provided source code or a url
83c86
<     Location codeLocation,
---
>     Location location,
89c92
<     self.codeLocation = codeLocation;
---
>     self.codeLocation = location;
94a98,107
>    * @notice Initializes a OCR2DR Request
>    * @dev Simplified version of initializeRequest for PoC
>    * @param self The uninitialized request
>    * @param javaScriptSource The user provided JS code (must not be empty)
>    */
>   function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {
>     initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);
>   }
> 
>   /**
99,103c112
<   function addSecrets(
<     Request memory self,
<     Location secretsLocation,
<     bytes memory secrets
<   ) internal pure {
---
>   function addInlineSecrets(Request memory self, bytes memory secrets) internal pure {
106c115
<     self.secretsLocation = secretsLocation;
---
>     self.secretsLocation = Location.Inline;


######################## DIFF for OCR2DRClient.sol
45c45
<     uint56 gasPrice
---
>     uint256 gasPrice
61c61
<     uint56 gasPrice
---
>     uint256 gasPrice
79c79
<     string memory err
---
>     bytes memory err
88c88
<     string memory err
---
>     bytes memory err


######################## DIFF for OCR2DROracle.sol
7d6
< import "../interfaces/OCR2DRRegistryInterface.sol";
13,19c12,13
< contract OCR2DROracle is OCR2DROracleInterface, OCR2Base, AuthorizedOriginReceiver {  
<   event OracleRequest(
<     bytes32 indexed requestId,
<     uint64 subscriptionId,
<     bytes requestData,
<     OCR2DRRegistryInterface.Commitment commitment
<   );
---
> contract OCR2DROracle is OCR2DROracleInterface, OCR2Base, AuthorizedOriginReceiver {
>   event OracleRequest(bytes32 indexed requestId, uint64 subscriptionId, bytes data);
96c90
<     uint56 gasPrice
---
>     uint256 gasPrice
114c108
<     bytes calldata requestData,
---
>     bytes calldata data,
116,120c110,112
<     uint56 gasPrice
<   // ??? Do we need to check if registry is set for every single call?
<   ) external override registryIsSet validateAuthorizedSender returns (bytes32) {
<     // ??? What is the reason for adding this null check? If it isn't necessary, is it worth the gas cost?
<     if (requestData.length == 0) {
---
>     uint256 gasPrice
>   ) external override registryIsSet returns (bytes32) {
>     if (data.length == 0) {
123,124c115,116
<     (bytes32 requestId, OCR2DRRegistryInterface.Commitment memory commitment) = s_registry.startBilling(
<       requestData,
---
>     bytes32 requestId = s_registry.startBilling(
>       data,
127c119
<     emit OracleRequest(requestId, subscriptionId, requestData, commitment);
---
>     emit OracleRequest(requestId, subscriptionId, data);
159,162d150
<     // Can we just set a resonable constant value to account for the gas used for report validation?
<     // This would also eliminate one of the variable factors for users to determine cost
<     // (ie: their cost changes based on how many request fulfillments are bundled into a single transmission)
<     // It would also slightly reduce gas usage.


######################## DIFF for OCR2DROracleFactory.sol
5c5
< import "@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol";
---
> import "../../interfaces/TypeAndVersionInterface.sol";


######################## DIFF for OCR2DRRegistry.sol
4,5c4,5
< import "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";
< import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
---
> import "../../interfaces/LinkTokenInterface.sol";
> import "../../interfaces/AggregatorV3Interface.sol";
9,11c9,11
< import "@chainlink/contracts/src/v0.8/interfaces/TypeAndVersionInterface.sol";
< import "@chainlink/contracts/src/v0.8/interfaces/ERC677ReceiverInterface.sol";
< import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
---
> import "../../interfaces/TypeAndVersionInterface.sol";
> import "../../interfaces/ERC677ReceiverInterface.sol";
> import "../../ConfirmedOwner.sol";
31d30
<   error TimeoutExeeded();
42,65d40
<   error GasLimitTooBig(uint32 have, uint32 want);
<   error InvalidLinkWeiPrice(int256 linkWei);
<   error IncorrectRequestID();
<   error PaymentTooLarge();
<   error Reentrant();
< 
<   event BillingEnd(
<     uint64 subscriptionId,
<     bytes32 indexed requestId,
<     uint96 signerPayment,
<     uint96 transmitterPayment,
<     uint96 totalCost,
<     // Gas used for callback is required for tooling.  Users need to be able to track `fulfillRequest` gas usage within the simulator to ensure it falls within reasonable limits
<     uint24 gasUsedByCallback,
<     bool success
<   );
<   event RequestTimedOut(bytes32 indexed requestId);
<   event SubscriptionCreated(uint64 indexed subscriptionId, address owner);
<   event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);
<   event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);
<   event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);
<   event SubscriptionCanceled(uint64 indexed subscriptionId, address to, uint256 amount);
<   event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);
<   event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);
67a43,62
>   struct Subscription {
>     // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)
>     uint96 balance; // Common LINK balance that is controlled by the Registry to be used for all consumer requests.
>     uint96 blockedBalance; // LINK balance that is reserved to pay for pending consumer requests.
>   }
>   // We use the config for the mgmt APIs
>   struct SubscriptionConfig {
>     address owner; // Owner can fund/withdraw/cancel the sub.
>     address requestedOwner; // For safely transferring sub ownership.
>     // Maintains the list of keys in s_consumers.
>     // We do this for 2 reasons:
>     // 1. To be able to clean up all keys from s_consumers when canceling a subscription.
>     // 2. To be able to return the list of all consumers in getSubscription.
>     // Note that we need the s_consumers map to be able to directly check if a
>     // consumer is valid without reading all the consumers from storage.
>     address[] consumers;
>   }
>   // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.
>   mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subscriptionId */ /* nonce */
>     private s_consumers;
72,75d66
<   mapping(uint64 => mapping(address => bool)) /* subscriptionId */ /* consumer */ /* isAuthorized */
<     private s_isAuthorizedConsumer;
<   // Use contract-wide nonce instead
<   uint256 private s_nonce;
84c75,88
<   
---
>   event SubscriptionCreated(uint64 indexed subscriptionId, address owner);
>   event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);
>   event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);
>   event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);
>   event SubscriptionCanceled(uint64 indexed subscriptionId, address to, uint256 amount);
>   event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);
>   event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);
> 
>   error GasLimitTooBig(uint32 have, uint32 want);
>   error InvalidLinkWeiPrice(int256 linkWei);
>   error IncorrectRequestID();
>   error PaymentTooLarge();
>   error Reentrant();
> 
86a91,101
>   struct Commitment {
>     uint64 subscriptionId;
>     address client;
>     uint32 gasLimit;
>     uint256 gasPrice;
>     address don;
>     uint96 donFee;
>     uint96 registryFee;
>     uint96 estimatedCost;
>     uint256 timestamp;
>   }
89,91c104,118
<   // If we can save gas by only checking the hash, use the code below instead
<   // mapping(bytes32 => bytes32) /* requestID */ /* Commitment hash */
<   //   private s_requestCommitmentHashes;
---
>   event BillingStart(bytes32 requestId, Commitment commitment);
>   struct ItemizedBill {
>     uint96 signerPayment;
>     uint96 transmitterPayment;
>     uint96 totalCost;
>   }
>   event BillingEnd(
>     uint64 subscriptionId,
>     bytes32 indexed requestId,
>     uint96 signerPayment,
>     uint96 transmitterPayment,
>     uint96 totalCost,
>     bool success
>   );
>   event RequestTimedOut(bytes32 indexed requestId);
107c134
<     uint16 requestTimeoutSeconds;
---
>     uint32 requestTimeoutSeconds;
139c166
<     uint16 requestTimeoutSeconds
---
>     uint32 requestTimeoutSeconds
250c277
<     uint56 gasPrice,
---
>     uint256 gasPrice,
261c288
<     uint256 paymentNoFee = (1e18 * uint256(gasPrice) * executionGas) / uint256(weiPerUnitLink);
---
>     uint256 paymentNoFee = (1e18 * gasPrice * executionGas) / uint256(weiPerUnitLink);
278c305
<     returns (bytes32, Commitment memory)
---
>     returns (bytes32)
280,281d306
<     SubscriptionConfig memory subscriptionConfig = s_subscriptionConfigs[billing.subscriptionId];
< 
283c308
<     if (subscriptionConfig.owner == address(0)) {
---
>     if (s_subscriptionConfigs[billing.subscriptionId].owner == address(0)) {
286,298c311,315
< 
<     // // It's important to ensure that the consumer is in fact who they say they
<     // // are, otherwise they could use someone else's subscription balance.
<     // // A nonce of 0 indicates consumer is not allocated to the sub.
<     // // uint64 currentNonce = s_consumers[billing.client][billing.subscriptionId];
<     // // if (currentNonce == 0) {
<     // //   revert InvalidConsumer(billing.subscriptionId, billing.client);
<     // // }
< 
<     // ??? Is storing the nonce per subscription & consumer really necessary?  It uses an extra slot of storage and doesn't appear to be essential.
<     // We can use a single nonce for the entire registry contract instead of per subscription
<     // Instead, do this to validate if a consumer is authorized:
<     if (!s_isAuthorizedConsumer[billing.subscriptionId][billing.client]) {
---
>     // It's important to ensure that the consumer is in fact who they say they
>     // are, otherwise they could use someone else's subscription balance.
>     // A nonce of 0 indicates consumer is not allocated to the sub.
>     uint64 currentNonce = s_consumers[billing.client][billing.subscriptionId];
>     if (currentNonce == 0) {
301d317
< 
318,322c334,335
<     // ??? Use contract-wide nonce instead?
<     // uint64 nonce = currentNonce + 1;
<     bytes32 requestId = computeRequestId(billing.subscriptionId, s_nonce);
<     s_subscriptions[billing.subscriptionId].pendingRequestCount++;
<     s_nonce++;
---
>     uint64 nonce = currentNonce + 1;
>     bytes32 requestId = computeRequestId(msg.sender, billing.client, billing.subscriptionId, nonce);
329c342
<       // msg.sender,
---
>       msg.sender,
333c346
<       uint40(block.timestamp)
---
>       block.timestamp
336,337d348
<     // If we can save gas by only checking the hash, use the code below instead
<     //s_requestCommitmentHashes[requestId] = keccak256(abi.encode(commitment));
340,345c351,353
<     // Do we still need to emit this if we are already emitting an oracle request?
<     // Is it worth the gas?
<     // emit BillingStart(requestId, commitment);
<     // s_consumers[billing.client][billing.subscriptionId] = nonce; *This is not needed
< 
<     return (requestId, commitment);
---
>     emit BillingStart(requestId, commitment);
>     s_consumers[billing.client][billing.subscriptionId] = nonce;
>     return requestId;
348a357,358
>     address don,
>     address client,
350,352c360,362
<     uint256 nonce
<   ) private view returns (bytes32) {
<     return keccak256(abi.encode(address(this), subscriptionId, nonce));
---
>     uint64 nonce
>   ) private pure returns (bytes32) {
>     return keccak256(abi.encode(don, client, subscriptionId, nonce));
401,402d410
<     // If we can save gas by only checking the hash, use the code below instead
<     // Commitment calldata commitment,
410,424c418
<     // If we can save gas by only checking the hash, use the code below instead
<     // if (keccak256(abi.encode(commitment)) != s_requestCommitmentHashes[requestId]) {
<     //   revert IncorrectRequestHash();
<     // }
<     
<     // Do we want to explicitly enforce timeouts? IE: if a timeout is exceeded and an oracle tries
<     // to fulfill, should it still be able to be filfilled or should it just be timed out?
<     // (Example: uApp escrow service: https://youtu.be/Ar4WobMZLy0
<     //  If this timeout is not enforced, there could be a "double redeem" if they misuse their logic.)
<     // If yes, use the commented out code below
<     // If a request has timed out, the commitment is deleted and the pending request count for the subscription is decremented
<     // if (timeoutRequest(requestId)) {
<     //   return true;
<     // }
<     if (commitment.client == address(0)) {
---
>     if (commitment.don == address(0)) {
428d421
<     s_subscriptions[commitment.subscriptionId].pendingRequestCount--;
434c427
<       string(err)
---
>       err
612,616c605
<     s_subscriptions[currentsubscriptionId] = Subscription({
<       balance: 0,
<       blockedBalance: 0,
<       pendingRequestCount: 0
<     });
---
>     s_subscriptions[currentsubscriptionId] = Subscription({balance: 0, blockedBalance: 0});
668d656
<    * @return success - returns true if removal was successful, else returns false
675d662
<     returns (bool)
677,678c664
<     // Note bounded by MAX_CONSUMERS
<     if (!s_isAuthorizedConsumer[subscriptionId][consumer]) {
---
>     if (s_consumers[consumer][subscriptionId] == 0) {
681c667
<     delete s_isAuthorizedConsumer[subscriptionId][consumer];
---
>     // Note bounded by MAX_CONSUMERS
691,692c677
<         emit SubscriptionConsumerRemoved(subscriptionId, consumer);
<         return true;
---
>         break;
695c680,681
<     return false;
---
>     delete s_consumers[consumer][subscriptionId];
>     emit SubscriptionConsumerRemoved(subscriptionId, consumer);
712a699,705
>     if (s_consumers[consumer][subscriptionId] != 0) {
>       // Idempotence - do nothing if already added.
>       // Ensures uniqueness in s_subscriptions[subscriptionId].consumers.
>       return;
>     }
>     // Initialize the nonce to 1, indicating the consumer is allocated.
>     s_consumers[consumer][subscriptionId] = 1;
714c707
<     s_isAuthorizedConsumer[subscriptionId][consumer] = true;
---
> 
729,734c722
<     // We CANNOT use this current logic for checking for pending requests as it relies upon iterating through the AuthorizedSenders array.
<     // if (pendingRequestExists(subscriptionId)) {
<     //   revert PendingRequestExists();
<     // }
<     // Instead, keep an active count of pending requests
<     if (uint256(s_subscriptions[subscriptionId].pendingRequestCount) > 0) {
---
>     if (pendingRequestExists(subscriptionId)) {
737d724
< 
741a729
>     SubscriptionConfig memory subConfig = s_subscriptionConfigs[subscriptionId];
743d730
<     address[] memory consumers = s_subscriptionConfigs[subscriptionId].consumers;
746,747c733,734
<     for (uint256 i = 0; i < consumers.length; i++) {
<       delete s_isAuthorizedConsumer[subscriptionId][consumers[i]];
---
>     for (uint256 i = 0; i < subConfig.consumers.length; i++) {
>       delete s_consumers[subConfig.consumers[i]][subscriptionId];
758,796d744
< 
<   // This function CANNOT be used it its current form.  It has O(n^2) gas usage as the
<   // authorized consumer array grows
< 
<   // My suggestion: we need a mapping to an array of pending requestIds for each subId
<   // mapping(bytes32 => uint64[]) pendingRequestIds;
< 
<   // /**
<   //  * @notice Check to see if there exists a request commitment for all consumers for a given sub.
<   //  * @param subscriptionId - ID of the subscription
<   //  * @return true if there exists at least one unfulfilled request for the subscription, false
<   //  * otherwise.
<   //  * @dev Looping is bounded to MAX_CONSUMERS*(number of DONs). (incorrect)
<   //  * @dev Used to disable subscription canceling while outstanding request are present.
<   //  */
< 
<   // function pendingRequestExists(uint64 subscriptionId) public view returns (bool) {
<   //   address[] memory consumers = s_subscriptionConfigs[subscriptionId].consumers;
<   //   address[] memory authorizedSendersList = getAuthorizedSenders();
<   //   for (uint256 i = 0; i < consumers.length; i++) {
<   //     for (uint256 j = 0; j < authorizedSendersList.length; j++) {
<   //       bytes32 requestId = computeRequestId(
<   //         authorizedSendersList[j],
<   //         consumers[i],
<   //         subscriptionId,
<   //         s_consumers[consumers[i]][subscriptionId]
<   //       );
<   //       if (s_requestCommitments[requestId].subscriptionId == 0) {
<   //         return true;
<   //       }
<   //     }
<   //   }
<   //   return false;
<   // }
< 
<   function getPendingRequestCount(uint64 subscriptionId) external view returns (uint32) {
<     return s_subscriptions[subscriptionId].pendingRequestCount;
<   }
< 
798,804c746,751
<    * @notice Search for all expired requestIds for a given subscriptionId.
<    * Start & end nonce should be specified in case the nonce search space
<    * becomes to large & exceeds the virtual gas limit for view functions
<    * @param subscriptionId SubscriptionId to search
<    * @param startNonce Nonce to start search 
<    * @param endNonce Nonce to end search
<    * @return timedOutRequestIds requestIds which must be passed to the timeoutRequests() function
---
>    * @notice Check to see if there exists a request commitment for all consumers for a given sub.
>    * @param subscriptionId - ID of the subscription
>    * @return true if there exists at least one unfulfilled request for the subscription, false
>    * otherwise.
>    * @dev Looping is bounded to MAX_CONSUMERS*(number of DONs).
>    * @dev Used to disable subscription canceling while outstanding request are present.
806,821c753,767
<   function getRequestsToTimeOut(uint64 subscriptionId, uint256 startNonce, uint256 endNonce)
<     external
<     view
<     returns (bytes32[] memory)
<   {
<     bytes32[] memory timedOutRequestIds = new bytes32[](s_subscriptions[subscriptionId].pendingRequestCount);
<     uint256 i = 0;
<     for (; startNonce < endNonce; startNonce++) {
<       bytes32 requestId = computeRequestId(subscriptionId, startNonce);
<       if (
<         s_requestCommitments[requestId].timestamp != uint40(0)
<         && block.timestamp >
<         (uint256(s_requestCommitments[requestId].timestamp) + s_config.requestTimeoutSeconds)
<       ) {
<         timedOutRequestIds[i] = requestId;
<         i++;
---
> 
>   function pendingRequestExists(uint64 subscriptionId) public view returns (bool) {
>     address[] memory consumers = s_subscriptionConfigs[subscriptionId].consumers;
>     address[] memory authorizedSendersList = getAuthorizedSenders();
>     for (uint256 i = 0; i < consumers.length; i++) {
>       for (uint256 j = 0; j < authorizedSendersList.length; j++) {
>         bytes32 requestId = computeRequestId(
>           authorizedSendersList[j],
>           consumers[i],
>           subscriptionId,
>           s_consumers[consumers[i]][subscriptionId]
>         );
>         if (s_requestCommitments[requestId].don == address(0)) {
>           return true;
>         }
824c770
<     return timedOutRequestIds;
---
>     return false;
828,829c774
<    * @notice Time out all provided requests if they are expired:
<    * unlocks funds, deletes request commitment, and decrements number of pending requests for the subscription
---
>    * @notice Time out all expired requests: unlocks funds and removes the ability for the request to be fulfilled
835,837c780,781
<       timeoutRequest(requestIdsToTimeout[i]);
<     }
<   }
---
>       bytes32 requestId = requestIdsToTimeout[i];
>       Commitment memory commitment = s_requestCommitments[requestId];
839,846c783,786
<   /**
<    * @notice Times out a request if it is expired:
<    * unlocks funds, deletes request commitment, and decrements number of pending requests for the subscription
<    * @param requestIdToTimeout - A list of request IDs to time out
<    * @return If the request is not expired, returns false, else returns true
<    */
<   function timeoutRequest(bytes32 requestIdToTimeout) internal returns(bool) {
<     Commitment memory commitment = s_requestCommitments[requestIdToTimeout];
---
>       // Check that the message sender is the subscription owner
>       if (msg.sender != s_subscriptionConfigs[commitment.subscriptionId].owner) {
>         revert MustBeSubOwner(s_subscriptionConfigs[commitment.subscriptionId].owner);
>       }
848,858c788,794
<     if (
<       (uint256(commitment.timestamp) + uint256(s_config.requestTimeoutSeconds))
<       > block.timestamp
<     ) {
<       // Decrement blocked balance
<       s_subscriptions[commitment.subscriptionId].blockedBalance -= commitment.estimatedCost;
<       // Delete commitment
<       delete s_requestCommitments[requestIdToTimeout];
<       s_subscriptions[commitment.subscriptionId].pendingRequestCount--;
<       emit RequestTimedOut(requestIdToTimeout);
<       return true;
---
>       if (commitment.timestamp + s_config.requestTimeoutSeconds > block.timestamp) {
>         // Decrement blocked balance
>         s_subscriptions[commitment.subscriptionId].blockedBalance -= commitment.estimatedCost;
>         // Delete commitment
>         delete s_requestCommitments[requestId];
>         emit RequestTimedOut(requestId);
>       }
860d795
<     return false;


######################## DIFF for OCR2Base.sol
4,5c4,5
< import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
< import "@chainlink/contracts/src/v0.8/dev/ocr2/OCR2Abstract.sol";
---
> import "../../ConfirmedOwner.sol";
> import "./OCR2Abstract.sol";


######################## DIFF for AuthorizedReceiverInterface.sol


######################## DIFF for OCR2DRClientInterface.sol
26c26
<     string memory err
---
>     bytes memory err


######################## DIFF for OCR2DROracleInterface.sol
60c60
<     uint56 gasPrice
---
>     uint256 gasPrice
75c75
<     uint56 gasPrice
---
>     uint256 gasPrice


######################## DIFF for OCR2DRRegistryInterface.sol
8,38d7
<   // The modified sizes below reduce commitment storage size by 1 slot (2 slots if we remove DON address)
<   // To futher improve gas usage, only the commitment hash should be stored on-chain and the
<   // rest of the commit data should be provided on fulfillment (verified using the hash)
<   struct Commitment {
<     uint64 subscriptionId;  // 8 bytes
<     address client;         // 20 bytes
<     uint32 gasLimit;        // 4 bytes 
<     uint56 gasPrice;        // 7 bytes (good for >100,000 gwei gas price)
<     // Do we need to store the DON address? It appears we don't use it at all.
<     // If we remove this, the commitment size goes from 100 bytes to 80, saving a full slot of storage
<     // address don;            // 20 bytes?
<     uint96 donFee;          // 12 bytes
<     uint96 registryFee;     // 12 bytes
<     uint96 estimatedCost;   // 12 bytes
<     uint40 timestamp;       // 5 bytes (good for >1000 years)
<   }
< 
<   struct ItemizedBill {
<     uint96 signerPayment;
<     uint96 transmitterPayment;
<     uint96 totalCost;
<     uint24 gasUsedByCallback;
<   }
< 
<   struct Subscription {
<     // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)
<     uint96 balance; // Common LINK balance that is controlled by the Registry to be used for all consumer requests.
<     uint96 blockedBalance; // LINK balance that is reserved to pay for pending consumer requests.
<     uint32 pendingRequestCount; // pendingRequestCount used to prevent a subscription with pending requests from being deleted
<   }
< 
48c17
<     uint56 gasPrice;
---
>     uint256 gasPrice;
51,63d19
<   // We use the config for the mgmt APIs
<   struct SubscriptionConfig {
<     address owner; // Owner can fund/withdraw/cancel the sub.
<     address requestedOwner; // For safely transferring sub ownership.
<     // Maintains the list of keys in s_consumers.
<     // We do this for 2 reasons:
<     // 1. To be able to clean up all keys from s_consumers when canceling a subscription.
<     // 2. To be able to return the list of all consumers in getSubscription.
<     // Note that we need the s_consumers map to be able to directly check if a
<     // consumer is valid without reading all the consumers from storage.
<     address[] consumers;
<   }
< 
92c48
<     uint56 gasPrice,
---
>     uint256 gasPrice,
104c60
<   function startBilling(bytes calldata data, RequestBilling calldata billing) external returns (bytes32, Commitment memory);
---
>   function startBilling(bytes calldata data, RequestBilling calldata billing) external returns (bytes32);